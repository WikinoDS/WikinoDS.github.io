<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.542">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vinicius Aquino">
<meta name="dcterms.date" content="2024-01-22">

<title>Gradient Boosting Aplicado à Séries Temporais</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="qmd_file_files/libs/clipboard/clipboard.min.js"></script>
<script src="qmd_file_files/libs/quarto-html/quarto.js"></script>
<script src="qmd_file_files/libs/quarto-html/popper.min.js"></script>
<script src="qmd_file_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="qmd_file_files/libs/quarto-html/anchor.min.js"></script>
<link href="qmd_file_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="qmd_file_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="qmd_file_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="qmd_file_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="qmd_file_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Gradient Boosting Aplicado à Séries Temporais</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vinicius Aquino </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">January 22, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="sec-sumario" class="level2">
<h2 class="anchored" data-anchor-id="sec-sumario">Sumário</h2>
<p>  <a href="#sec-sumario" class="quarto-xref">Sumário&nbsp;1</a> <br>   <a href="#sec-resumo" class="quarto-xref">Resumo&nbsp;2</a> <br>   <a href="#sec-regressao-linear-e-series-temporais" class="quarto-xref">Regressão Linear e Séries Temporais&nbsp;3</a> <br>    <a href="#sec-modelando-tendencia" class="quarto-xref">Modelando Tendência -{&nbsp;3.1</a> <br>    <a href="#sec-sazonalidade-mensal" class="quarto-xref">Modelando Sazonalidade Mensal -{&nbsp;4</a> <br>    <strong>?@sec-validacao-cruzada</strong> <br>  <a href="#sec-variaveis-exogenas-e-consideracoes-finais" class="quarto-xref">Variáveis Exógenas e Considerações Finais&nbsp;5</a> <br></p>
</section>
<section id="sec-resumo" class="level2">
<h2 class="anchored" data-anchor-id="sec-resumo">Resumo</h2>
<p>O texto parte do princípio que o leitor tem um conhecimento básico sobre o que é uma regressão linear. Nele apresenta como esse modelo pode ser usado no contexto de séries temporais. Na maioria absoluta das vezes o uso de regressão linear no contexto de séries temporais é dispensado, dado que modelos da classe ARMA tem a capacidade de comportar tendências (ARIMA), sazonalidade (SARMA) e variáveis exógenas (ARMAX). Os modelos da classe ARMA podem se dizer “extensões” de regressões lineares aplicadas à séries temporais, no entanto, o entendimento de como comportar regressões lineares para séries temporais é o que vai permitir o leitor a entender como funcionam regressões não paramétricas, em especial algoritimos baseados em árvores de decisão (LightGBM e XGboost, por exemplo), podem ser usadas para este tipo de problema.</p>
<p>Para esse exercício, será o dataset beer sales, que reúne uma série histórica de vendas de cerveja. O <a href="https://raw.githubusercontent.com/flo7up/relataly_data/main/alcohol_sales/BeerWineLiquor.csv">dataset</a> junto aos pacotes usados podem ser vistos abaixo.</p>
<p>Pacotes usados:</p>
<div id="78b4c926" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pmdarima.model_selection <span class="im">import</span> SlidingWindowForecastCV</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="56cb9966" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>warnings.simplefilter(action<span class="op">=</span><span class="st">'ignore'</span>, category<span class="op">=</span><span class="pp">FutureWarning</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>path <span class="op">=</span> <span class="st">"https://raw.githubusercontent.com/flo7up/relataly_data/main/alcohol_sales/BeerWineLiquor.csv"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Dataset:</p>
<div id="31a64560" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.read_csv(path, parse_dates<span class="op">=</span>[<span class="st">'date'</span>], index_col<span class="op">=</span>[<span class="st">'date'</span>])</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>df.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">beer</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-01-01</td>
<td>1509</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1992-02-01</td>
<td>1541</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-03-01</td>
<td>1597</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1992-04-01</td>
<td>1675</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-05-01</td>
<td>1822</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="25ee7322" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-5-output-1.png" width="669" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-regressao-linear-e-series-temporais" class="level2">
<h2 class="anchored" data-anchor-id="sec-regressao-linear-e-series-temporais">Regressão Linear e Séries Temporais</h2>
<p>
</p><p>Uma observação sempre pertinente sobre Regressão Linear é que existe essencialmente dois modelos diferentes e eventualmente coincidentes: existe a regressão linear como modelo matemático que minimiza quadrados ordinários e existe a regressão linear como modelo probabilístico que produz estimadores não enviesados de menor variância possível (BLUE). Isso é, existe a regressão linear da álgebra linera e a regressão linear da estatística. No escopo deste texto, aprendizado de máquina supervisionado, será visto o primeiro modelo. Isso é, a nossa regressão linear vai ser pensada como um algoritimo que encontra uma estimativa para um modelo com parâmetros lineares entre si, minimizando o quadrado dos resíduos em treino sem fazer suposições a cerca do comportamento dos resíduos.</p>
<p>No contexto de Séries Temporais, o que pode-se fazer com regressão linear é estimar modelos “mecanisticos” para sua variável aleatória <span class="math inline">\(y_t\)</span>. O “mecanístico” vem lá da Física Mecânica mesmo. Estimar uma função de posição ao longo do tempo para a sua variável e adicionar covariáveis para explicar isto. O desafio vai ser especificar essa função de forma que capte melhor o movimento da variável. Um ponto interessante é que como está se estimando a “velocidade” de crescimento, é interessante não usar um dataset tão grande, para que estime velocidades “locais”.</p>
<p>Além disso, é interessante pontuar que se modela separadamente (no memso modelo, mas com “fatores” próprios para cada) os diferentes componentes de uma série temporal. No caso, para o dataset a ser usado, há componentes de <i>tendência</i> e <i>sazonalidade mensal</i> a serem controlados e que serão adicionados por partes no modelo. A idéia é controlar esses fatores até que os erros do modelo sejam meramente ao acaso, ou, como é visto nos modelos ARIMA, sejam “ruídos brancos”.</p>
<section id="sec-modelando-tendencia" class="level3">
<h3 class="anchored" data-anchor-id="sec-modelando-tendencia">Modelando Tendência:</h3>
<p>Para o nosso dataset, vamos sugerir inicialmente dois modelos mais simples de tendência:</p>
<p>Demanda com crescimento constante e linear: <span class="math display">\[y_{t} = \beta_{0} + \beta_{1}t\]</span></p>
<ul>
<li>Isso é, nossa demanda segue um “movimento retilinio uniforme”, onde a velocidade é dada por <span class="math inline">\(\beta_{1}\)</span> e a posição inicial é dada por <span class="math inline">\(\beta_{0}\)</span></li>
</ul>
<p>Demanda com crescimento exponencial: <span class="math display">\[y_{t} = \beta_{0} e^{\beta_{1}t}\]</span></p>
<ul>
<li>Nesse caso, o modelo não seria linear, mas pode-se linearizá-lo usando o logaritimo de <span class="math inline">\(y_{t}\)</span>:</li>
</ul>
<p><span class="math display">\[ln(y_{t}) = ln(\beta_{0}) + \beta_{1}t\]</span></p>
<p>Interessante notar que na prática os dois modelos têm a mesma cara, mas um está olhando para a variável em nível e o outro para o logaritimo da variável.</p>
<p>Modelando em Python:</p>
<div id="ec5f68b1" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">60</span> <span class="co"># tamanho da amostra de treinamento</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> pd.DataFrame({<span class="st">'y'</span>: df.iloc[:n, <span class="dv">0</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'b0'</span>: np.ones(n), </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                        <span class="st">'b1'</span>: np.arange(<span class="dv">0</span>, n)}) <span class="co"># Dataset a ser trabalhado </span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                        </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>df_train.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">y</th>
<th data-quarto-table-cell-role="th">b0</th>
<th data-quarto-table-cell-role="th">b1</th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th">date</th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th"></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-01-01</td>
<td>1509</td>
<td>1.0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1992-02-01</td>
<td>1541</td>
<td>1.0</td>
<td>1</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-03-01</td>
<td>1597</td>
<td>1.0</td>
<td>2</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1992-04-01</td>
<td>1675</td>
<td>1.0</td>
<td>3</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">1992-05-01</td>
<td>1822</td>
<td>1.0</td>
<td>4</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<p><br><br></p>
<div id="2c815dc4" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Treinando Modelo 1</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>model_1 <span class="op">=</span> sm.OLS(df_train.y, df_train[[<span class="st">'b0'</span>, <span class="st">'b1'</span>]])</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>results_1 <span class="op">=</span> model_1.fit()</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_1.summary())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.091
Model:                            OLS   Adj. R-squared:                  0.076
Method:                 Least Squares   F-statistic:                     5.831
Date:                Mon, 22 Jan 2024   Prob (F-statistic):             0.0189
Time:                        22:33:51   Log-Likelihood:                -412.79
No. Observations:                  60   AIC:                             829.6
Df Residuals:                      58   BIC:                             833.8
Df Model:                           1                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
b0          1714.4000     61.033     28.090      0.000    1592.230    1836.570
b1             4.3085      1.784      2.415      0.019       0.737       7.880
==============================================================================
Omnibus:                       29.551   Durbin-Watson:                   1.886
Prob(Omnibus):                  0.000   Jarque-Bera (JB):               52.993
Skew:                           1.700   Prob(JB):                     3.11e-12
Kurtosis:                       6.103   Cond. No.                         67.6
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
</div>
</div>
<p>O modelo estimado foi:</p>
<p><span class="math display">\[\hat{y_t} = 1714.40 + 4.31t\]</span></p>
<p><br><br></p>
<div id="d9e8478a" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Treinando Modelo 2</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>model_2 <span class="op">=</span> sm.OLS(np.log(df_train.y), df_train[[<span class="st">'b0'</span>, <span class="st">'b1'</span>]])</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>results_2 <span class="op">=</span> model_2.fit()</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_2.summary())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.103
Model:                            OLS   Adj. R-squared:                  0.088
Method:                 Least Squares   F-statistic:                     6.659
Date:                Mon, 22 Jan 2024   Prob (F-statistic):             0.0124
Time:                        22:33:51   Log-Likelihood:                 43.407
No. Observations:                  60   AIC:                            -82.81
Df Residuals:                      58   BIC:                            -78.62
Df Model:                           1                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
b0             7.4425      0.030    244.475      0.000       7.382       7.503
b1             0.0023      0.001      2.580      0.012       0.001       0.004
==============================================================================
Omnibus:                       20.335   Durbin-Watson:                   1.801
Prob(Omnibus):                  0.000   Jarque-Bera (JB):               28.301
Skew:                           1.286   Prob(JB):                     7.15e-07
Kurtosis:                       5.170   Cond. No.                         67.6
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
</div>
</div>
<p>O modelo estimado foi:</p>
<p><span class="math display">\[\hat{y_t} = 1707.01 e^{0.0023t}\]</span></p>
<p>Fazendo previsões com os modelos:</p>
<div id="6cd0d806" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">24</span> <span class="co"># Intervalo de predição</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>input_predict <span class="op">=</span> pd.DataFrame({<span class="st">'b0'</span>: np.ones(h), </span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                              <span class="st">'b1'</span>: np.arange(n, n<span class="op">+</span>h)})</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>predict_model_1 <span class="op">=</span> results_1.predict(input_predict[[<span class="st">'b0'</span>, <span class="st">'b1'</span>]])</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Lembrando que o modelo enxerga o logaritimo, por isso o exp</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>predict_model_2 <span class="op">=</span> np.exp(results_2.predict(input_predict[[<span class="st">'b0'</span>, <span class="st">'b1'</span>]])) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fbe0e5e3" class="cell" data-execution_count="9">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-10-output-1.png" width="658" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><br><br></p>
<div id="14995d5e" class="cell" data-execution_count="10">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-11-output-1.png" width="658" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><br><br></p>
<p>No caso, os dois modelos, de certa forma, pegaram bem a tendência da série. A questão está nos padrões dos erros relacionados a sazonalidade mensal.</p>
</section>
</section>
<section id="sec-sazonalidade-mensal" class="level2">
<h2 class="anchored" data-anchor-id="sec-sazonalidade-mensal">Sazonalidade Mensal</h2>
<p>Apesar da modelagem da tendência ter sido bem sucedida, é vizualmente nítido que há um forte padrão nos erros. Todo mês de janeiro, a previsão fica abaixo, por exemplo. O ponto em questão agora é saber como se dá a estrutura desse erro. Na prática, o que será feito é estimar o “empurrãozinho” que cada mês dá nessa reta estimada. Dá mesma forma que a tendência pode ser linear ou exponencial, a sazonalidade pode ser aditiva ou multiplicativa. No caso da aditiva, é, todo mês, adicionado um fator ao nível da série (negativo ou positivo). No caso da multiplicativa, todo mês o nível da série é multiplicado por um fator diferente.</p>
<p>No caso, o Modelo 1 terá sazonalidade aditiva. O novo modelo 1 pode ser visto como:</p>
<p><span class="math display">\[y_{t} = \beta_{0} + \beta_{1}t + \beta_{jan} x_{jan} + \beta_{fev} x_{fev} + ... + \beta_{nov} x_{nov}\]</span></p>
<p>Onde <span class="math inline">\(x_{jan}\)</span> vale 1 se é o mês de janeiro, 0 caso contrário. As demais variáveis se comportam do mesmo jeito. Isso é, para o mês de julho, por exemplo, o valor esperado de <span class="math inline">\(y_{t}\)</span> é dado por: <span class="math inline">\(\hat{y_{t}} = \beta_{0} + \beta_{1}t + \beta_{jul}\)</span>.</p>
<p>Para o Modelo 2 será usada a sazonalidade multiplicativa. Sendo o modelo 2:</p>
<p><span class="math display">\[y_{t} = \beta_{0} e^{\beta_{1}t} e^{\beta_{jan}x_{jan}} e^{\beta_{fev} x_{fev}} ... e^{\beta_{nov} x_{nov}}\]</span></p>
<p>Linearizando o modelo:</p>
<p><span class="math display">\[ln(y_{t}) = ln(\beta_{0}) + \beta_{1}t +\beta_{jan} x_{jan} + \beta_{fev} x_{fev} + ... + \beta_{nov} x_{nov}\]</span></p>
<p>No caso, citando novamente o mês de julho, o valor esperado seria <span class="math inline">\(y_{t} = \beta_{0} e^{\beta_{1}t} e^{\beta_{jul}}\)</span>, dado que as demais variáveis <span class="math inline">\(x_{mes}\)</span> seriam 0 e <span class="math inline">\(e^{0} = 1\)</span>. Sendo, portanto, <span class="math inline">\(e^{\beta_{jul}}\)</span> o efeito do mês de julho na demanda.</p>
<p>Você pode ter se perguntado: “E dezembro?”. Bom, aí entra o tal problema da multicolinearidade. Se no modelo tiver os 12 meses como variáveis dummies, então a coluna do intercepto (que vale 1) vai ser a soma de todas as colunas de sazonalidade, o que seria uma colinearidade perfeita.</p>
<p>Modelando em Python:</p>
<div id="890d157a" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Criando um dataframe com variáveis dummies:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>df_sazo <span class="op">=</span> pd.get_dummies(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                        pd.DataFrame({<span class="st">"mes_"</span>: [i.month <span class="cf">for</span> i <span class="kw">in</span> df.index[:n]]}),</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                        columns<span class="op">=</span>[<span class="st">'mes_'</span>],</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>                        prefix<span class="op">=</span><span class="st">"mes"</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                         )                        </span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>df_train <span class="op">=</span> pd.concat([df_train.reset_index(drop<span class="op">=</span><span class="va">True</span>), </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                      df_sazo], axis<span class="op">=</span><span class="dv">1</span>).astype(<span class="bu">int</span>).drop(labels<span class="op">=</span>[<span class="st">'mes_12'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>df_train.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="34">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">y</th>
<th data-quarto-table-cell-role="th">b0</th>
<th data-quarto-table-cell-role="th">b1</th>
<th data-quarto-table-cell-role="th">mes_1</th>
<th data-quarto-table-cell-role="th">mes_2</th>
<th data-quarto-table-cell-role="th">mes_3</th>
<th data-quarto-table-cell-role="th">mes_4</th>
<th data-quarto-table-cell-role="th">mes_5</th>
<th data-quarto-table-cell-role="th">mes_6</th>
<th data-quarto-table-cell-role="th">mes_7</th>
<th data-quarto-table-cell-role="th">mes_8</th>
<th data-quarto-table-cell-role="th">mes_9</th>
<th data-quarto-table-cell-role="th">mes_10</th>
<th data-quarto-table-cell-role="th">mes_11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1509</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1541</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1597</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1675</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1822</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="5a3844eb" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>model_1_sazo <span class="op">=</span> sm.OLS(df_train.y, df_train.iloc[:, <span class="dv">1</span>:])</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>results_1_sazo <span class="op">=</span> model_1_sazo.fit()</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_1_sazo.summary())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.963
Model:                            OLS   Adj. R-squared:                  0.954
Method:                 Least Squares   F-statistic:                     103.1
Date:                Mon, 22 Jan 2024   Prob (F-statistic):           1.58e-29
Time:                        22:33:51   Log-Likelihood:                -316.44
No. Observations:                  60   AIC:                             658.9
Df Residuals:                      47   BIC:                             686.1
Df Model:                          12                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
b0          2452.3424     27.773     88.300      0.000    2396.471    2508.214
b1             2.3674      0.406      5.832      0.000       1.551       3.184
mes_1       -928.1590     34.043    -27.265      0.000    -996.644    -859.674
mes_2       -965.9264     33.992    -28.417      0.000   -1034.309    -897.544
mes_3       -803.6938     33.946    -23.676      0.000    -871.983    -735.404
mes_4       -787.8611     33.904    -23.238      0.000    -856.068    -719.654
mes_5       -676.2285     33.868    -19.967      0.000    -744.362    -608.095
mes_6       -671.9958     33.836    -19.860      0.000    -740.065    -603.926
mes_7       -570.7632     33.809    -16.882      0.000    -638.779    -502.747
mes_8       -641.7306     33.787    -18.993      0.000    -709.702    -573.759
mes_9       -742.8979     33.770    -21.999      0.000    -810.835    -674.961
mes_10      -711.8653     33.758    -21.087      0.000    -779.778    -643.953
mes_11      -667.0326     33.751    -19.763      0.000    -734.931    -599.135
==============================================================================
Omnibus:                        0.822   Durbin-Watson:                   1.482
Prob(Omnibus):                  0.663   Jarque-Bera (JB):                0.877
Skew:                           0.258   Prob(JB):                        0.645
Kurtosis:                       2.710   Cond. No.                         430.
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
</div>
</div>
<p>No caso, para o mês de julho, o modelo estimado foi: <span class="math display">\[\hat{y_{t}} = 1518.57 + 2.37t + 181.50 = 1700.07 + 2.37t\]</span></p>
<div id="8282e6b8" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>model_2_sazo <span class="op">=</span> sm.OLS(np.log(df_train.y), df_train.iloc[:, <span class="dv">1</span>:])</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>results_2_sazo <span class="op">=</span> model_2_sazo.fit()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(results_2_sazo.summary())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                            OLS Regression Results                            
==============================================================================
Dep. Variable:                      y   R-squared:                       0.956
Model:                            OLS   Adj. R-squared:                  0.945
Method:                 Least Squares   F-statistic:                     85.87
Date:                Mon, 22 Jan 2024   Prob (F-statistic):           9.41e-28
Time:                        22:33:51   Log-Likelihood:                 134.11
No. Observations:                  60   AIC:                            -242.2
Df Residuals:                      47   BIC:                            -215.0
Df Model:                          12                                         
Covariance Type:            nonrobust                                         
==============================================================================
                 coef    std err          t      P&gt;|t|      [0.025      0.975]
------------------------------------------------------------------------------
b0             7.7926      0.015    511.965      0.000       7.762       7.823
b1             0.0013      0.000      5.801      0.000       0.001       0.002
mes_1         -0.4585      0.019    -24.574      0.000      -0.496      -0.421
mes_2         -0.4823      0.019    -25.892      0.000      -0.520      -0.445
mes_3         -0.3828      0.019    -20.578      0.000      -0.420      -0.345
mes_4         -0.3728      0.019    -20.065      0.000      -0.410      -0.335
mes_5         -0.3104      0.019    -16.724      0.000      -0.348      -0.273
mes_6         -0.3083      0.019    -16.623      0.000      -0.346      -0.271
mes_7         -0.2548      0.019    -13.750      0.000      -0.292      -0.218
mes_8         -0.2927      0.019    -15.807      0.000      -0.330      -0.255
mes_9         -0.3470      0.019    -18.748      0.000      -0.384      -0.310
mes_10        -0.3297      0.019    -17.821      0.000      -0.367      -0.292
mes_11        -0.3058      0.018    -16.530      0.000      -0.343      -0.269
==============================================================================
Omnibus:                        1.008   Durbin-Watson:                   1.449
Prob(Omnibus):                  0.604   Jarque-Bera (JB):                1.071
Skew:                           0.231   Prob(JB):                        0.585
Kurtosis:                       2.536   Cond. No.                         430.
==============================================================================

Notes:
[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.</code></pre>
</div>
</div>
<p>E, novamente tomando julho como exemplo, o modelo estimado foi:</p>
<p><span class="math display">\[\hat{y_t} = e^{\hat{\beta_0}} e^{\hat{\beta_1}t} e^{\hat{\beta_{jul}}} = 604.68 e^{0.0013t} 1.762 =  1065.45 e^{0.0013t}\]</span></p>
<p>Fazendo previsões com os modelos:</p>
<div id="4fb2a960" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>input_predict <span class="op">=</span> pd.DataFrame({<span class="st">'b0'</span>: np.ones(h), </span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>                              <span class="st">'b1'</span>: np.arange(n, n<span class="op">+</span>h)})</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>df_sazo_predict <span class="op">=</span> pd.get_dummies(</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>                                pd.DataFrame({<span class="st">"mes_"</span>: [i.month <span class="cf">for</span> i <span class="kw">in</span> df.index[n:n<span class="op">+</span>h]]}),</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>                                columns<span class="op">=</span>[<span class="st">'mes_'</span>],</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>                                prefix<span class="op">=</span><span class="st">"mes"</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>                                ).astype(<span class="bu">int</span>).drop(labels<span class="op">=</span>[<span class="st">'mes_12'</span>], axis<span class="op">=</span><span class="dv">1</span>)     </span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>input_predict_sazo <span class="op">=</span> pd.concat([input_predict,</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>                                df_sazo_predict],</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>                                axis<span class="op">=</span><span class="dv">1</span>)                                                 </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>predict_model_1_sazo <span class="op">=</span> results_1_sazo.predict(input_predict_sazo)</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Lembrando que o modelo enxerga o logaritimo, por isso o exp</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>predict_model_2_sazo <span class="op">=</span> np.exp(results_2_sazo.predict(input_predict_sazo)) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b548bf69" class="cell" data-execution_count="15">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-16-output-1.png" width="658" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="66f2b47b" class="cell" data-execution_count="16">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-17-output-1.png" width="658" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="3541c617" class="cell" data-execution_count="17">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-18-output-1.png" width="658" height="433" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><br><br></p>
<p>Nesse caso, ambos modelos apresentam um comportamento muito parecido. No caso, isso deve-se e muito a amostra escolhida. É nítido que os primeiros 5 anos apresentam uma tendência menor, o que faz que ambos modelos tenham uma tendência quase nula. O que pode-se fazer agora é modularizar o código e fazer uma validação cruzada do previsto.</p>
<section id="sec-validacao-cruazada" class="level3">
<h3 class="anchored" data-anchor-id="sec-validacao-cruazada">Validação Cruzada:</h3>
<p>A idéia da validação cruzada é bem simples: treinar o modelo inúmeras vezes com amostras distintas pra ver analisar a capacidade de extrapolação.</p>
<div id="41b7bdf2" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>cv <span class="op">=</span> SlidingWindowForecastCV(step<span class="op">=</span><span class="dv">12</span>, </span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>                             h<span class="op">=</span><span class="dv">24</span>, </span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>                             window_size<span class="op">=</span><span class="dv">72</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>cv_generator <span class="op">=</span> cv.split(df)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1ef76fc1" class="cell" data-execution_count="19">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-20-output-1.png" width="757" height="1134" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><br><br></p>
<p>Nesse caso, serão treinados 20x cada modelo com amostras diferentes (mas não tãããão independentes, dado que uma observação aparece 5x em cada amostra) e será avaliado o desempenho de cada um prevendo dois anos seguintes. Criando uma função que prevê os dois anos seguintes:</p>
<ul>
<li>Dataset com os inputs:</li>
</ul>
<div id="6fa7fa09" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>df_cv <span class="op">=</span> df.copy()</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>df_cv.columns <span class="op">=</span> [<span class="st">'y'</span>]</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>df_cv[<span class="st">'b0'</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>df_cv[<span class="st">'b1'</span>] <span class="op">=</span> np.arange(<span class="bu">len</span>(df_cv))</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>dummies_sazo <span class="op">=</span> pd.get_dummies(pd.DataFrame({<span class="st">"mes"</span>: df_cv.index.month}), columns<span class="op">=</span>[<span class="st">"mes"</span>]).astype(<span class="bu">int</span>).drop(labels<span class="op">=</span>[<span class="st">'mes_12'</span>], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>df_cv <span class="op">=</span> pd.concat([df_cv.reset_index(drop<span class="op">=</span><span class="va">True</span>), </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>                   dummies_sazo], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>df_cv.head()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="43">
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">y</th>
<th data-quarto-table-cell-role="th">b0</th>
<th data-quarto-table-cell-role="th">b1</th>
<th data-quarto-table-cell-role="th">mes_1</th>
<th data-quarto-table-cell-role="th">mes_2</th>
<th data-quarto-table-cell-role="th">mes_3</th>
<th data-quarto-table-cell-role="th">mes_4</th>
<th data-quarto-table-cell-role="th">mes_5</th>
<th data-quarto-table-cell-role="th">mes_6</th>
<th data-quarto-table-cell-role="th">mes_7</th>
<th data-quarto-table-cell-role="th">mes_8</th>
<th data-quarto-table-cell-role="th">mes_9</th>
<th data-quarto-table-cell-role="th">mes_10</th>
<th data-quarto-table-cell-role="th">mes_11</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>1509</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>1541</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>1597</td>
<td>1</td>
<td>2</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>1675</td>
<td>1</td>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>1822</td>
<td>1</td>
<td>4</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<ul>
<li>Função que treina o modelo e prevê os próximos h períodos:</li>
</ul>
<div id="a7e3fcc2" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fit_predict(df_train: pd.DataFrame, df_test: pd.DataFrame, h: <span class="bu">int</span>, log: <span class="bu">bool</span>):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    model <span class="op">=</span> sm.OLS(np.log(df_train.iloc[:, <span class="dv">0</span>]) <span class="cf">if</span> log <span class="cf">else</span> df_train.iloc[:, <span class="dv">0</span>], </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>                   df_train.iloc[:, <span class="dv">1</span>:])</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> model.fit()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    predict <span class="op">=</span> np.exp(result.predict(df_test.iloc[:, <span class="dv">1</span>:])) <span class="cf">if</span> log <span class="cf">else</span> result.predict(df_test.iloc[:, <span class="dv">1</span>:])</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> predict </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Validação cruzada:</li>
</ul>
<div id="5570ec50" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>cv_generator <span class="op">=</span> cv.split(df)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>log_win <span class="op">=</span> np.zeros(n, dtype<span class="op">=</span><span class="bu">float</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    index <span class="op">=</span> <span class="bu">next</span>(cv_generator)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    predict_lin <span class="op">=</span> fit_predict(df_cv.iloc[index[<span class="dv">0</span>]], df_cv.iloc[index[<span class="dv">1</span>]], <span class="dv">12</span>, <span class="va">False</span>)</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>    predict_log <span class="op">=</span> fit_predict(df_cv.iloc[index[<span class="dv">0</span>]], df_cv.iloc[index[<span class="dv">1</span>]], <span class="dv">12</span>, <span class="va">True</span>)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    sqr_lin <span class="op">=</span> ((predict_lin <span class="op">-</span>  df_cv.iloc[index[<span class="dv">1</span>], <span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    sqr_log <span class="op">=</span> ((predict_log <span class="op">-</span>  df_cv.iloc[index[<span class="dv">1</span>], <span class="dv">0</span>])<span class="op">**</span><span class="dv">2</span>).<span class="bu">sum</span>()</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sqr_log <span class="op">&lt;</span> sqr_lin:</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>        log_win[i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Modelo log performou melhor em </span><span class="sc">{</span><span class="dv">100</span><span class="op">*</span>log_win<span class="sc">.</span>mean()<span class="sc">}</span><span class="ss">% das vezes"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Modelo log performou melhor em 70.0% das vezes</code></pre>
</div>
</div>
<div id="5b66eb28" class="cell" data-execution_count="23">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="qmd_file_files/figure-html/cell-24-output-1.png" width="757" height="1134" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p><br><br></p>
<p>Nesse caso, o modelo que prevê o logaritimo, e tem por trás suposição de um crescimento exponencial e sazonalidade multiplicativa, performa acima e, pode-se dizer, de forma satisfatória.</p>
</section>
</section>
<section id="sec-variaveis-exogenas-e-consideracoes-finais" class="level2">
<h2 class="anchored" data-anchor-id="sec-variaveis-exogenas-e-consideracoes-finais">Variáveis Exógenas e Considerações Finais</h2>
<p>
</p><p>Além de variáveis relacionadas ao mês e ano, poderia ter sido utilizado variáveis externa a demanda total, como preços e promoções. Uma ressalva quanto a variáveis exógenas em modelos de séries temporais é a incerteza da sua variável no momento de predição. Você sabe exatamente qual foi a temperatura média, quantos foram os clientes e quais promoções foram feitas no passado, mas provavelmente não sabe como serão no futuro e, desta forma, não é aconselhado usá-los. Isso porque em treino você usou o valor real e em produção vai usar a PREVISÃO do valor, contendo uma incerteza que vai produzir uma performance aquém do esperado. Pode-se usar variáveis com componentes de incerteza, contanto que se faça um estudo prévio para mensurar a performance do modelo trabalhando com a incerteza, sem incorrer em <i>data lakage</i>.</p>
Quanto ao uso da Regressão Linear em Séries Temporais, apesar de produzir uma performance interessante, recomenda-se o uso de modelos SARIMA que, além de poder comportar tendências polinomiais e exponenciais (tudo depende da especificação), permite estimar estruturas para os efeitos sazonais. Enquanto a Regressão Linear vai assumir efeitos fixos, SARIMA estimam estes efeitos, mas também analisando como os resíduos estão autocorrelacionados ao longo dessa do tempo. Em resumo, não há nada que modelos de regressão linear façam em séries temporais, que os modelos SARIMA não podem fazer, incluindo até mesmo o uso de variáveis exógenas na previsão (SARIMAX).
<p></p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>